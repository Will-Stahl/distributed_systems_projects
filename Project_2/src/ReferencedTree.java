import java.io.Serializable;
import java.util.*;

/**
 * tree where each node contains an index, a value, and a list of child nodes
 * an ancillary array uses these indices to reference each node directly
 * updates are quick and it can be iterated recursively or by order of creation
 */
public class ReferencedTree implements Serializable {
    private class ReferencedNode implements Serializable {
        public int ID;
        public String article;
        public ArrayList<ReferencedNode> children;

        public ReferencedNode(int ID, String article) {
            this.ID = ID;
            this.article = article;
        }
    }
    private ReferencedNode root;
    private ArrayList<ReferencedNode> directList;

    public ReferencedTree() {
        root = new ReferencedNode(0, "root node");
        root.children = new ArrayList<ReferencedNode>();
        directList = new ArrayList<ReferencedNode>();
        directList.add(root);
    }

    // Second constructor for initializing a copy of another tree
    public ReferencedTree(ReferencedTree tree){
        root = new ReferencedNode(tree.root.ID, tree.root.article);
        root.children = new ArrayList<ReferencedNode>();
        directList = new ArrayList<ReferencedNode>();
        directList.add(root);

        for (ReferencedNode child : tree.root.children){
            createDeepCopy(root, child);
        }
    }

    private void createDeepCopy(ReferencedNode parent, ReferencedNode child){
        ReferencedNode node = new ReferencedNode(child.ID, child.article);
        node.children = new ArrayList<ReferencedNode>();
        parent.children.add(node);
        directList.add(node);

        for (ReferencedNode successor : child.children){
            createDeepCopy(node, successor);
        }
    }

    /**
     * @param article new article to publish
     * returns false if replyTo doesn't exist
     * @param newID unique ID generated by coordinator
     * false if newID != the new index added to directList
     * @param replyTo ID of article to reply to, highest level if 0
     */
    public boolean AddNode(int newID, String article, int replyTo) {
        ReferencedNode replyToNode = directList.get(replyTo);
        //System.out.println("ID: " + newID);
        //System.out.println("Article:" + article);

        if (replyToNode == null) {
            return false;
        }
        if (directList.size() != newID) {
            return false;  // tried to add wrong unique ID
        }
        ReferencedNode toAdd = new ReferencedNode(newID, article);
        toAdd.children = new ArrayList<ReferencedNode>();
        replyToNode.children.add(toAdd);
        directList.add(toAdd);
        return true;
    }

    /**
     * returns preview of all articles with indentation and IDs
     */
    public String ReadTree() {
        String result = "";
        for (ReferencedNode child : root.children) {
            result += ReadChild(child, "");
        }
        System.out.println(root.children.size());
        System.out.println(result);
        return result;
    }

    /**
     * recursive helper for Read()
     */
    private String ReadChild(ReferencedNode parent, String indent) {
        String result = "\n" + indent + parent.ID + ".  " + parent.article;
        if (parent.article.length() > 16) {  // too long, cut to preview
            // TODO: Fix minor bug with article preview
            result += parent.article.substring(0, 12) + "...";
        }
        for (ReferencedNode child : parent.children) {
            result += ReadChild(child, indent + "  ");
        }
        return result;
    }

    public String GetAtIndex(int idx) {
        if (directList.size() == 1 || idx > directList.size()){
            return null;
        }

        ReferencedNode node = directList.get(idx);
        if (node == null) {
            return null;
        }
        return node.article;
    }

}